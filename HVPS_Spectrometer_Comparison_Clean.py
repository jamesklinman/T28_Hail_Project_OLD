# -*- coding: utf-8 -*-
"""
Created on Tue Aug  1 10:00:40 2023

@author: james.klinman

Takes bin adjusted files!
takes spec and normalizes the ocncentration
hvps data is prepped
produces PSD
currently works well for 10 sec ranges. Not properly tested for other time ranges.
Not tested for non 5interval chunks of time either    have notes need to implement

!!!!string to delete is not automated yet

!!!plot and table titles are wrong and need to account for if it's just five seconds or whatever

runfile('HVPS_Spectrometer_Comparison_Clean.py', args='Particle_Concs/06222000_232921_HVPS1.txt Particle_Concs/06222000_232921_HAIL.txt Param_Info/757_paramInfo.txt Sensor_Information/HHMMSS_True_Calc_Airspeed_757.txt Flight_Files/757.nc Param_Info/757_paramInfo.txt')
runfile('HVPS_Spectrometer_Comparison_Clean.py', args='Particle_Concs/06222000_232921_HVPS1.txt Particle_Concs/disp757.0 Param_Info/757_paramInfo.txt Sensor_Information/HHMMSS_True_Calc_Airspeed_757.txt Flight_Files/757.nc Param_Info/757_paramInfo.txt')
"""

import os
import sys
import pandas as pd
import numpy as np
import Top_Hail_Methods as hail
import matplotlib.pyplot as plt
import math
import netCDF4
from datetime import date

"""
Global variables. Need to get rid of them all if possible

Should all now be sys.argv's
"""

filenameHVPS = sys.argv[1]
filenameSpec = sys.argv[2]
paramInfo = sys.argv[3]
TASfilename = sys.argv[4]
planefile = sys.argv[5]



#Clarifying the initial variables/chunk that we want to look at
#they are manually found at the moment
"""
starttime = '2353'
endtime = '232830'
"""

initParameters = pd.read_csv(paramInfo, sep=' * ', engine='python')

starttime = str(initParameters['Time_Start'][0])
endtime = str(initParameters['Time_End'][0])

timeZone = int(initParameters['Timezone_True'][0])

"""
HVPS_Indx_Start = 154   
HVPS_Indx_End = 162   #179
"""
"""
filenameHVPS = 'Particle_Concs/HVPSBinAdj' #updated is TAS corrected
filenameSpec = 'Particle_Concs/HailSpec_SizeDistr_668.0' #updated is TAS corrected

#True calculated airspeed of aircraft per second
TASfile = pd.read_csv('Sensor_Information/HHMMSS_True_Calc_Airspeed_668.txt', sep=' * ')
"""
TASfile = pd.read_csv(TASfilename, sep=' * ')
airplanedata = netCDF4.Dataset(planefile)

"""
#Time period chunks for data in seconds
TimeResolution = 10  #interavls of 5 currently
"""
TimeResolution = int(initParameters['PSD_Time_Res'][0])




"""
Tenative no Indpt Variabeles past this point
"""
HvpsPreChunk = 5  #hvps data from SODA is already chunked into n seconds. Put n here 

#creating corrections for spectrometer data
#the 0 is bc below the range is 1-14
BinSize = np.array([0, .1, .1, .1, .1, .14, .16, .20, .26, .30, .31, .44, .60,\
                    .79, 1])
BinSize = BinSize / 100 #to correct for cm -> m

#Correction var. Surface area of spec probe.
#is m^2
SA = .1

#X axis'   -   both are done with the min bin points, so it reads as 
#              .02-.04 for the first bin, 3.21-4 for the last bin
#HVPS 
xaxis = np.array([.02, .04, .06, .08, .1, .12, .14, .16, .18, .22, .26, .3, .35, .4, .5, .6, .7, .8, .94, 1.1, 1.3, 1.56, 1.86, 2.17, 2.61, 3.21])
#Specstrometer. last bin is 4-5cm
xaxis2 = np.array([.4, .5, .6, .7, .8, .94, 1.1, 1.3, 1.56, 1.86, 2.17, 2.61, 3.21, 4])

xaxis3 = np.array([.02, .04, .06, .08, .1, .12, .14, .16, .18, .22, .26, .3, .34, .38, .42, .46, .5, .6, .7, .8, .9, 1, 1.5, 2, 2.5])


#Preping HVPS data

HVPSData = pd.read_csv(filenameHVPS, sep=' * ', header=22)
tempdf = pd.DataFrame(HVPSData)
tempdf = tempdf.drop(index=0)
HVPSData = pd.DataFrame.reset_index(tempdf)
#HVPSDataDF = pd.DataFrame(HVPSData) 
#note for below, minimum time resolution can be 5

#try and except because so far two variations f hail spectormeter data have
#been run through this program. The try works if the data file is from SODA,
#and the except works for the output generated by the South Dakota School of Mines
try:
    #easier to read spec data from SODA
    SpecData = pd.read_csv(filenameSpec, sep=' * ', header=22)
    tempdf2 = pd.DataFrame(SpecData)
    tempdf2 = tempdf2.drop(index=0)
    SpecData = pd.DataFrame.reset_index(tempdf2)
    #HVPSDataDF = pd.DataFrame(HVPSData) 
    #note for below, minimum time resolution can be 5
    
    #determines which if statement to enter in a couple of the steps later on
    new_spec_file_tracker = 'y'

except:
    #Preping Spectrometer data
    #got the below chunk of code from https://stackoverflow.com/questions/7356043/how-to-delete-specific-strings-from-a-file
    #it deletes all the new page headers that are attached to the rows of data
    #strToDelete = ['F l i g h t  668  22-Jun-95  Hail Info'] #header to delete for each page
    strToDelete = ['F l i g h t  757  22-Jun-0  Hail Info'] 
    endoffiletodelete = '-=-'
    fin = open(filenameSpec, "r")
    fout = open("Random/Spec_Corrected_File", "w+")
    for line in fin:
        for word in strToDelete:
            line = line.replace(word, "")
        fout.write(line)
    fin.close()
    fout.close()
    
    #first loop from https://pynative.com/python-count-number-of-lines-in-file/
    #gets length of file and get reads in just the spec data
    with open(r"Random/Spec_Corrected_File", 'r') as file:
        for count, line in enumerate(file):
            pass
        FileLen = count + 1
    Spacing = 55 #spacing between rows to skip                                           #indpt var!!!!!
    RowsToSkip = []
    RowsToSkip.append(57)
    NewHeadSkip = 57
    while NewHeadSkip <= FileLen:
        NewHeadSkip += Spacing
        RowsToSkip.append((NewHeadSkip))
    SpecFile = "Random/Spec_Corrected_File"
    SpecData = pd.read_csv(SpecFile, sep=' * ', header=0, skiprows=RowsToSkip)
    #spec data is stored in local time not utc. need to add 6hrs
    
    #need this since the files are in their local timezones time instead of utc
    starttimeSpec = hail.HHMMSS_adjustHH(starttime, (-(timeZone)))
    endtimeSpec = hail.HHMMSS_adjustHH(endtime, (-(timeZone)))
    starttimeSpec = hail.forceHHMMSS(starttimeSpec)
    endtimeSpec = hail.forceHHMMSS(endtimeSpec)
    
    #determines which if statement to enter in a couple of the steps later on 
    new_spec_file_tracker = 'n'


"""
NO INDEPENDENT VARIABLES BELOW THIS LINE
"""


#converting HVPS data to HHMMSS format so it matches spectrometer format
#HVPS data from SODA is typically in UTC, which is why the timezone isn't
#included in the function
templist = []
for x in HVPSData['Time']:
    templist.append(int(x))
HVPSTimeConv = hail.seconds_HHMMSS(templist)

#!NOTE
#this assumes no flights started after 2:59 UTC
if int(airplanedata['TIME_HOURS_20Hz'][0][0]) > 3:
    if starttime[0:2] == '00':
        adjustHH = 24
    elif int(starttime[0:2]) <= 3:
        adjustHH = 24
    else:
        adjustHH = 0

#the adjustment is just making sure that the time didn't go back to 0 hours
#after 24hrs since the HVPS and spec data need it to be in the 24+ hr format
starttime_adjust = hail.HHMMSS_adjustHH(starttime, adjustHH)
endtime_adjust = hail.HHMMSS_adjustHH(endtime, adjustHH)
starttime_adjust = hail.forceHHMMSS(starttime_adjust)
endtime_adjust = hail.forceHHMMSS(endtime_adjust)

HVPS_Indx_Start = hail.find_loc_in_array_1D(HVPSData['Time'],
                                            hail.HHMMSS_2_SS([starttime_adjust])[0])
HVPS_Indx_End = hail.find_loc_in_array_1D(HVPSData['Time'], 
                                          hail.HHMMSS_2_SS([endtime_adjust])[0])

#try and except because so far two variations f hail spectormeter data have
#been run through this program. The try works if the data file is from SODA,
#and the except works for the output generated by the South Dakota School of Mines
if new_spec_file_tracker == 'y':
    SpecStartTimeIndx = hail.find_loc_in_array_1D(SpecData['Time'], hail.HHMMSS_2_SS([starttime_adjust])[0])
    SpecEndTimeIndx = hail.find_loc_in_array_1D(SpecData['Time'], hail.HHMMSS_2_SS([endtime_adjust])[0])

#if you're getting an error with the start and endtimeSpec, then copy the method
#from the starttime_adjust for the HVPS for the Spec here. Not tested since I
#haven't run f668 through this updated program yet
elif new_spec_file_tracker == 'n':
    #below gets the start and end index in the spectrometer data
    #not issue tested for if the index is in line with one of the omitted rows
    SpecStartTimeIndx = None
    SpecEndTimeIndx = None
    tempiter = 0
    for x in SpecData['Time']:
        if x == '-=-':
            break
        if str(int(float(x))) == str(starttime_adjust): #need starttimeSPec if its 1995, but adjust if it's 2000   .....
            SpecStartTimeIndx = tempiter
        if str(int(float(x))) == str(endtime_adjust):
            SpecEndTimeIndx = tempiter
            break
        else:
            tempiter +=1


starttimeTAS = hail.HHMMSS_resetHH(starttime)
endtimeTAS = hail.HHMMSS_resetHH(endtime)

starttimeTAS = hail.forceHHMMSS(starttimeTAS)
endtimeTAS = hail.forceHHMMSS(endtimeTAS)

PlaneStartIndx = None
PlaneEndIndx = None
tempiter = 0
#TAS file is in HHMMSS and resets after 24hrs 
for x in TASfile['HHMMSS']:
    if int(x) == int(starttimeTAS):
        PlaneStartIndx = tempiter
    if int(x) == int(endtimeTAS):
        PlaneEndIndx = tempiter
        break
    else:
        tempiter +=1 
        

        
#Plane speeds for time range list
#Have to correct for missing lines in Spec data
#thats what the second for loop with the if statement does
PlaneSpeeds = []
for x in range(PlaneStartIndx, PlaneEndIndx + 1):
    for y in range(SpecStartTimeIndx, SpecEndTimeIndx + 1):
        if (int(SpecData['Time'][y])) == int(TASfile['HHMMSS'][x]):
            PlaneSpeeds.append(TASfile['Calc_Airspeed'][x])
        else:
            pass




HvpsPlotLists = [] #Will be summed up Conc over specified time period. Stored as per time period
HvpsTimeRes = TimeResolution / HvpsPreChunk  #since hvps is already in chunks of 5sec
#rounding up so enough lists for all data). -1 bc we're counting up to the time
#chunk, and don't want to include the second of the next time chunk
for x in range(math.ceil((HVPS_Indx_End - HVPS_Indx_Start) / HvpsTimeRes)): 
    HvpsPlotLists.append([])
tempiter = 0
concCount = 0
tempConc = None
for y in range(HVPS_Indx_End - HVPS_Indx_Start): #HVPS_Indx_End - HVPS_Indx_Start    
    tempSum = HvpsPlotLists[tempiter]
    if y==0:
        pass
    elif y%HvpsTimeRes == 1: #this sums up over a period of n seconds or chunks. if 1 then %1 =0 if 2 then %2 = 1 if 3 then %3    #INDPT VAR
        lowIndx = HVPS_Indx_Start + y - HvpsTimeRes
        highIndx = HVPS_Indx_Start + y
        for x in range(25): #need to get an auto way of counting conc's in hvps, was 26
            concCount += 1
            if concCount < 10:
                tempConc = 'Conc' + str(0)+str(0)+str(concCount)
            else:
                tempConc = 'Conc' + str(0)+str(concCount)
            tempSum.append(np.sum(HVPSData[str(tempConc)][int(lowIndx):int(highIndx)]))
        tempiter += 1
        concCount = 0
    elif y == (HVPS_Indx_End - HVPS_Indx_Start - 1): #this just sums up the remaining data that is less than n seconds
        lowIndx = HVPS_Indx_Start + y - HvpsTimeRes
        highIndx = HVPS_Indx_Start + y
        for x in range(25): #need to get an auto way of counting conc's in hvps,
            concCount += 1
            if concCount < 10:
                tempConc = 'Conc' + str(0)+str(0)+str(concCount)
            else:
                tempConc = 'Conc' + str(0)+str(concCount)    
            tempSum.append(np.sum(HVPSData[str(tempConc)][int(lowIndx):int(highIndx)]))
HvpsPlotListsArray = np.array(HvpsPlotLists)   

#try and except because so far two variations f hail spectormeter data have
#been run through this program. The try works if the data file is from SODA,
#and the except works for the output generated by the South Dakota School of Mines
if new_spec_file_tracker == 'y':
    #BUT FOR THE SPECTROMETER
    SpecPlotLists = [] #Will be summed up Conc over specified time period. Stored as per time period
    SpecTimeRes = TimeResolution / HvpsPreChunk  #since hvps is already in chunks of 5sec
    #rounding up so enough lists for all data). -1 bc we're counting up to the time
    #chunk, and don't want to include the second of the next time chunk
    for x in range(math.ceil((SpecEndTimeIndx - SpecStartTimeIndx) / HvpsTimeRes)):
        SpecPlotLists.append([])
    tempiter = 0
    concCount = 0
    tempConc = None
    for y in range(SpecEndTimeIndx - SpecStartTimeIndx): #HVPS_Indx_End - HVPS_Indx_Start    
        tempSum = SpecPlotLists[tempiter]
        print(y)
        if y==0:
            pass
        elif y%SpecTimeRes == 1: #this sums up over a period of n seconds or chunks. if 1 then %1 =0 if 2 then %2 = 1 if 3 then %3    #INDPT VAR
            lowIndx = SpecStartTimeIndx + y - HvpsTimeRes
            highIndx = SpecStartTimeIndx + y
            for x in range(25): #need to get an auto way of counting conc's in hvps,
                concCount += 1
                if concCount < 10:
                    tempConc = 'Conc' + str(0)+str(0)+str(concCount)
                else:
                    tempConc = 'Conc' + str(0)+str(concCount)
                tempSum.append(np.sum(SpecData[str(tempConc)][int(lowIndx):int(highIndx)]))
            tempiter += 1
            concCount = 0
        elif y == SpecEndTimeIndx - SpecStartTimeIndx - 1: #this just sums up the remaining data that is less than n seconds
            lowIndx = SpecStartTimeIndx + y - HvpsTimeRes
            highIndx = SpecStartTimeIndx + y
            for x in range(25): #need to get an auto way of counting conc's in hvps,
                concCount += 1
                if concCount < 10:
                    tempConc = 'Conc' + str(0)+str(0)+str(concCount)
                else:
                    tempConc = 'Conc' + str(0)+str(concCount)    
                tempSum.append(np.sum(SpecData[str(tempConc)][int(lowIndx):int(highIndx)]))
    SpecPlotListsArray = np.array(SpecPlotLists)            

elif new_spec_file_tracker == 'n':
    print('oogabooga')
    #applying corrections to the spectrometer data
    #range 1-14 since that the amount of bins in spec data
    ColumnRange = len(range(SpecStartTimeIndx, SpecEndTimeIndx + 1))
    SpecDataCorrected = np.array([[]])
    SpecDataCorrected = SpecDataCorrected.reshape(ColumnRange,0)
    for x in range(1, 15): #for bin x,    15 cause then it stops at 14
        BinCorrected = np.array([[]])
        for y in range(SpecStartTimeIndx, SpecEndTimeIndx + 1):#we want data for this range
            tempBin = float(SpecData[str(x)][y])
            BinCorrected = np.append(BinCorrected, tempBin)
        BinCorrected = np.array([BinCorrected]).reshape(ColumnRange, 1)
        BinCorrected = BinCorrected / BinSize[x] #Normalizing each bin for its change in size 
        if x == 1:
            print 
        SpecDataCorrected = np.append(SpecDataCorrected, BinCorrected, axis=1)
    
    SpecDataCorrected = SpecDataCorrected / SA #surface area of probe in m^-2   
    
    #the data is in the format SpecDataCorrected[timelocation][binnumber - 1]
    #Seperating into time chunks and applying TAS/sec correction in below code
    SpecCor = SpecDataCorrected.copy() #needed to make new copy for it to
                                       #properly apply airspeed normlaization
    for x in range(SpecCor.shape[0]):
        SpecCor[x] = SpecCor[x] / PlaneSpeeds[x]
        SpecCor[x] = SpecCor[x] * (PlaneSpeeds[x] / 100)
    
    SpecPlotLists = [] #Will be summed up Conc over specified time period. Stored as per time period
    #rounding up so enough lists for all data). -1 bc we're counting up to the time
    #chunk, and don't want to include the second of the next time chunk
    for x in range(math.ceil((SpecCor.shape[0] - 1)/TimeResolution)): 
        SpecPlotLists.append([])
    tempiter = 0
    for y in range(SpecCor.shape[0]):
        tempSum = SpecPlotLists[tempiter]
        if y==0:
            pass
        elif y%TimeResolution == 0: #this sums up over a period of 5 seconds
            tempy = y - TimeResolution
            for x in range(SpecCor.shape[1]):
                tempSum.append(np.sum(SpecCor[tempy:y][:,x]))
            tempiter += 1
        elif y == SpecCor.shape[0] - 1: #this just sums up the remaining data that is less than 5 seconds
            tempRange = SpecCor.shape[0] - 1 - tempiter * TimeResolution
            tempy = y - tempRange
            for x in range(SpecCor.shape[1]):
                tempSum.append(np.sum(SpecCor[tempy:y][:,x]))
    SpecPlotListsArray = np.array(SpecPlotLists)


print("0000000000000000000000000000000000000000000000000000000000000000000000000000000000")

#import scipy

FlightNum = str(getattr(airplanedata, 'FlightNumber'))
FlightDate = str(getattr(airplanedata, 'FlightDate'))
FlightDate = FlightDate.split('/')
FlightDate = FlightDate[2]+''+FlightDate[0]+''+FlightDate[1]

current_date = date.today()
file_created_date = current_date.strftime("%Y%m%d")

if os.path.exists('./PSD_Plots/' + file_created_date) is False:
    os.mkdir('./PSD_Plots/' + file_created_date)
if os.path.exists('./PSD_Tables/' + file_created_date) is False:
     os.mkdir('./PSD_Tables/' + file_created_date)

tempTime = HVPS_Indx_Start
for x in range(len(SpecPlotLists)): #len(SpecPlotLists)
    fig = plt.figure(figsize = [23.0,20.0]) #in x in
    # Plot title     need to include date
    #print(x, "x")
    tempRange = int(HVPSTimeConv[tempTime]) + TimeResolution
    timeRange = str(HVPSTimeConv[tempTime][0:2] +':'+
                    HVPSTimeConv[tempTime][2:4] +':'+
                    HVPSTimeConv[tempTime][4:6]) + "-" + str(
                        str(tempRange)[0:2] +':'+
                        str(tempRange)[2:4] +':'+
                        str(tempRange)[4:6])
    plt.title("HVPS & Hail Spectrometer,\n" + timeRange, fontsize=100)
    print('Hi')
    tableNameSpec = "./PSD_Tables/" + file_created_date + "/Spec_Conc_per_Bin_" + str(FlightDate)\
                    + '_' + HVPSTimeConv[tempTime]+'-'+ \
                      str(tempRange) +'.txt'
    filein = open(tableNameSpec, "w+")
    filein.write('{z:<7}{q:<18}{a:<18}'.format\
                   (z='Bin', q='Bin_Size_Min(cm)', a='Spec_Conc(#/m^4)'))
    filein.write('\n\n')
    if new_spec_file_tracker == 'y': 
        for y in range(xaxis3.shape[0]):
            filein.write('{z:<7}{q:<18}{a:<18}'.format(z=int(y +1), q=float(xaxis3[y]), a=SpecPlotListsArray[x][y]))
            filein.write('\n')
    elif new_spec_file_tracker == 'n':
        for y in range(xaxis2.shape[0]):
            filein.write('{z:<7}{q:<18}{a:<18}'.format(z=int(y +1), q=float(xaxis2[y]), a=SpecPlotListsArray[x][y]))
            filein.write('\n')
    filein.close()
        
    
    tableNameHvps = "./PSD_Tables/" + file_created_date + "/Hvps_Conc_per_Bin_" + str(FlightDate) \
                    + '_' + HVPSTimeConv[tempTime]+'-'+ \
                      str(tempRange) +'.txt'
    filein = open(tableNameHvps, "w+")
    filein.write('{z:<7}{q:<18}{b:<18}'.format\
                   (z='Bin', q='Bin_Size_Min(cm)', b='Hvps_Conc(#/m^4)'))
    filein.write('\n\n')
    for y in range(xaxis3.shape[0]):
        filein.write('{z:<7}{q:<18}{b:<18}'.format(z=int(y +1), q=float(xaxis3[y]), b=HvpsPlotListsArray[x][y]))
        filein.write('\n')
    filein.close()
    
    plt.yscale("log")
    testidx = np.isfinite(np.log(SpecPlotListsArray[x]), where=True)
    try:
        if new_spec_file_tracker == 'y': 
            plt.scatter(xaxis3[testidx], SpecPlotListsArray[x][testidx], label='Spectrometer', s=500)
        elif new_spec_file_tracker == 'n':
            plt.scatter(xaxis2[testidx], SpecPlotListsArray[x][testidx], label='Spectrometer', s=500)
            
    except UserWarning:
        print("Time Range " + str(timeRange) + " had no spectrometer data")
    
    testidx2 = np.isfinite(np.log(HvpsPlotListsArray[x]), where=True)
    try:
        plt.scatter(xaxis3[testidx2], HvpsPlotListsArray[x][testidx2], label='HVPS', s=500)

    except UserWarning:
        print("Time Range " + str(timeRange) + " had no HVPS data")
    
    plt.xticks(fontsize=100) 
    plt.yticks(fontsize=100)       
    plt.xlabel("Bin Size (cm)", fontsize=100)
    plt.ylabel("Conc (#/m^4)", fontsize=100)
    plt.legend(fontsize=100)
    #plt.plot = np.polyfit(xaxis2, np.log(SpecPlotLists[x]), 1)
    #HVPSFit = np.polyfit(xaxis, np.log(HvpsPlotLists[x]), 1)
    plt.show()
    fig.savefig('./PSD_Plots/' + file_created_date + '/HVPS v Spec, ' + str(FlightDate)\
                    + '_' + HVPSTimeConv[tempTime]+'-'+ \
                      str(tempRange) + '.png')#, bbox_inches = 'tight')
    fig.clf()
    
    tempTime += int(1 * HvpsTimeRes)







#notes to self. 
#   testing time 173154 173209
#   [197:205] for hvps HVPSTimeConv ['173144','173149', '173154', '173159', '173204', '173209', '173214', '173219']
#    54 and 04 are the interesting circle spots
#   New time to line up with pats range   154:173  ['172809','172944]
#automate picking of interesting data

#testidx = np.isfinite(np.log(SpecPlotListsArray[x]), where=True)
"""
def testfunc(ugy, a, b, c):
    print(ugy)
    return a * np.log(b * ugy) + c


ytesting = testfunc(SpecPlotListsArray[x][testidx], 1, 1, 0)
ynspectest = SpecPlotListsArray[x][testidx]

popt, pcov = scipy.optimize.curve_fit(testfunc, ytesting, xaxis2[testidx])
plt.plot(xaxis2[testidx], testfunc(xaxis2[testidx], *popt),'r-', label="pls")
"""
"""
ygamma2 = scipy.stats.gamma.pdf(np.log(SpecPlotLists[0]), a=3, scale=5)
ygamma2 = scipy.special.gamma(np.log(SpecPlotListsArray[x][testidx]), out=None)
ygamma2 = scipy.special.loggamma(SpecPlotListsArray[x][testidx], out=None)
plt.plot(xaxis2[testidx], ygamma2)
"""
"""
#ygamma2 = scipy.stats.gamma.pdf(np.log(SpecPlotLists[0]), a=3, scale=5)
#ygamma2 = scipy.special.gamma(np.log(SpecPlotLists[x]), out=None)
#plt.plot(xaxis2, ygamma2)
#plt.ylim(0, 10000000)

testidx = np.isfinite(np.log(SpecPlotListsArray[0]), where=True)
logfittest = np.polyfit(xaxis2, np.where(np.log(testidx) != 0, np.log(SpecPlotLists[x]), 0), 1)
Spectestsss = np.array([])
#for x in range(SpecPlotListsArray[0].shape[0])
trendtest = np.polyfit(xaxis2[testidx], np.log(SpecPlotListsArray[0][testidx]), 1)
trendtestpoly = np.poly1d(trendtest)
plt.plot(xaxis2[testidx], trendtestpoly)
#plt.plot(xaxis2, logfittest)
"""
"""
testidx2 = np.isfinite(np.log(HvpsPlotListsArray[x]), where=True)
ygamma3 = scipy.special.gamma(np.log(HvpsPlotListsArray[x][testidx2]), out=None)
plt.plot(xaxis[testidx2], ygamma3)
"""



"""def func(x, a, b, c):
    return a * np.exp(-b * x) + c
ytestt = func(SpecPlotListsArray[0], 2.5, 1.3, 0.5)
yntestt = ytestt + 0.2*np.random.normal(size=14)
scipy.optimize.curve_fit(func, xaxis2, yntestt)
testfit10 = scipy.optimize.curve_fit(func, xaxis2, yntestt)
plt.plot(xaxis2, testfit10)
"""

       #plt.plot = np.polyfit(xaxis2, np.log(SpecPlotLists[x]), 1)
       #testfit = scipy.optimize.curve_fit(lambda t,a,b: a*np.exp(-b*t), xaxis2, SpecPlotListsArray[x])
       #testfit2 = testfit(xaxis2, 1,1)
